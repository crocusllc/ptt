import os
import csv
import io
import jwt
import datetime
import psycopg2
import json
import psycopg2.extras
from flask import Flask, request, jsonify, send_file, current_app
from flask_cors import CORS
from passlib.hash import bcrypt
from functools import wraps

def is_json(str):
  try:
    json.loads(str)
  except ValueError as e:
    return False
  return True

def create_conn():
    # Set up DB engine
    conn = psycopg2.connect(
        dbname="{{PG_DB}}",
        user="{{PG_USER}}",
        password="{{PG_PWD}}",
        host="{{PG_HOST}}",
        port="{{PG_PORT}}"
    )

    return conn

def create_app():
    app = Flask(__name__)
    CORS(app, origins=["*"])

    # Set up DB engine
    app.config["SECRET_KEY"] = "{{SECRET_KEY}}"

    @app.route('/')
    def hello():
        # Simple health check or DB connection check
        try:
            conn = create_conn()
            cur = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)
            cur.execute("SELECT version();")
            db_version = cur.fetchone()
            cur.close()
            conn.close()
            return f"Hello, World! PostgreSQL version: {db_version}"
        except Exception as e:
            return f"Error connecting to DB: {e}"


    # ========== AUTH DECORATOR ==========
    def login_required(role_required=None):
        def decorator(f):
            @wraps(f)
            def decorated_function(*args, **kwargs):
                auth_header = request.headers.get('Authorization', None)
                if not auth_header or not auth_header.startswith("Bearer "):
                    return jsonify({"error": "Missing or invalid Authorization header"}), 401
                token = auth_header.split(" ")[1]
                try:
                    decoded = jwt.decode(token, app.config["SECRET_KEY"], algorithms=["HS256"])
                    request.user = decoded.get("sub")
                    request.user_role = decoded.get("role")
                    if role_required and request.user_role not in role_required:
                        return jsonify({"error": "Access denied"}), 403
                except jwt.ExpiredSignatureError:
                    return jsonify({"error": "Token expired"}), 401
                except jwt.InvalidTokenError:
                    return jsonify({"error": "Invalid token"}), 401
                return f(*args, **kwargs)
            return decorated_function
        return decorator

    # ========== LOGIN ENDPOINT ==========
    @app.route("/login", methods=["POST"])
    def login():
        data = request.get_json() or {}
        username = data.get("username")
        password = data.get("password")

        if not username or not password:
            return jsonify({"error": "Missing username/password"}), 400

        conn = create_conn()
        cur = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)

        cur.execute("SELECT user_role, password_hash, username from users where username=%s;", (username,))
        user = cur.fetchone()

        cur.close()
        conn.close()

        if not user:
            return jsonify({"error": "Invalid username or password"}), 401

        stored_hash = user['password_hash']

        if not bcrypt.verify(password, stored_hash):
            return jsonify({"error": "Invalid username or password"}), 401

        expiration = datetime.datetime.utcnow() + datetime.timedelta(hours=10)
        token = jwt.encode(
            {
                "sub": username,
                "role": user['user_role'],
                "exp": expiration
            },
            app.config["SECRET_KEY"],
            algorithm="HS256"
        )

        return jsonify({"token": token, "username": user['username'], "role": user['user_role']})

    # ========== FILE UPLOAD ENDPOINT ==========
    @app.route("/file_upload", methods=["POST"])
    @login_required(role_required=["administrator", "editor"])
    def file_upload():
        data = request.get_data()
        json_str = data.decode('utf-8')
        json_objs = json_str.split('\n')
        
        for obj in json_objs:
            if is_json(obj):
                metadata = json.loads(obj)

        if (metadata):
            file_name = metadata["file_name"]
            table_name = metadata["table_name"]
            fields = metadata["fields"]
        
            file_content = request.files['file']

            if not file_name or not table_name or not fields or not file_content:
                return jsonify({"error": "Missing file_name, table_name, fields, or file"}), 400
        
            # Read file content
            stream = io.StringIO(file_content.stream.read().decode("utf-8"))
            csv_reader = csv.DictReader(stream)

            if table_name not in ["student_info", "program_info", "clinical_placements"]:
                return jsonify({"error": "Invalid table_name"}), 400

            rows_to_insert = []
            for row in csv_reader:
                row_data = {field: row[field] if row[field] != '' else None for field in fields if field in row}
                rows_to_insert.append(row_data)

            # Insert data using psycopg2
            try:
                if rows_to_insert:
            # Extract column names
                    columns = list(rows_to_insert[0].keys())
                    values = [[row[col] for col in columns] for row in rows_to_insert]
            
            # Build INSERT query dynamically
                    query = f"""
                    INSERT INTO {table_name} ({', '.join(columns)}) 
                    VALUES ({', '.join(['%s' for _ in columns])})
                    """
                    conn = create_conn()
                    cur = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)
            # Execute batch insert
                    for row in values:
                        cur.execute(query, row)
                
                    conn.commit()

                    cur.close()
                    conn.close()
            except psycopg2.Error as e:
                return jsonify({"message": f"Database error: {e}", "file_name": file_name, "table_name": table_name})

            return jsonify({"message": "File uploaded successfully", "file_name": file_name, "table_name": table_name})

    # ========== FILE DOWNLOAD ENDPOINT ==========
    @app.route("/file_download", methods=["POST"])
    @login_required(role_required=["administrator", "viewer"])
    def file_download():
        data = request.get_json() or {}
        file_name = data.get("file_name")
        fields = data.get("fields", [])

        if not file_name or not fields:
            return jsonify({"error": "Missing file_name or fields"}), 400

        query_fields = ",".join(str(bit) for bit in fields)
        
        if query_fields == "":
             query_fields = "*"
 
        fields_not_date = fields.copy()

        start_date = ''
        end_date = ''
        exit_date = ''

        if query_fields != "*":
            for key in fields:
                if "date" in key:
                    fields_not_date.pop(key, None)

                    if "start" in key and fields[key] != '':
                        start_date = f'AND {key} >= \'{fields[key]}\'::date '
                    
                    if "end" in key and fields[key] != '':
                        end_date = f'AND {key} <= \'{fields[key]}\'::date '

                    if "exit" in key and fields[key] != '':
                        exit_date = f'AND {key} <= \'{fields[key]}\'::date '

                if fields[key] == '':
                    fields_not_date.pop(key, None)

            conditions = ' AND '.join([f'{key} like \'%{fields_not_date[key]}%\'' for key in fields_not_date])
        
            query_all = f'SELECT * FROM student_info s JOIN clinical_placements c ON s.id=c.student_id JOIN program_info p ON s.id=p.student_id WHERE {conditions} {start_date} {end_date} {exit_date};'
            query_all = query_all.replace("WHERE AND", "WHERE")
        else:
            query_all = f'SELECT * FROM student_info s JOIN clinical_placements c ON s.id=c.student_id JOIN program_info p ON s.id=p.student_id;'

        conn = create_conn()
        cur = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)
        
        cur.execute(query_all)
        results = cur.fetchall()

        cur.close()
        conn.close()

        if len(results) > 1:
            output = io.StringIO()
            writer = csv.writer(output)

            if fields == ["*"]:
                writer.writerow(results[0].keys())
            else:
                writer.writerow(fields)

            for row in results:
                if fields == ["*"]:
                    writer.writerow([row[field] for field in results[0].keys()])
                else:
                    writer.writerow([row[field] for field in fields])

            output.seek(0)
            return send_file(
                io.BytesIO(output.getvalue().encode("utf-8")),
                mimetype="text/csv",
                as_attachment=True,
                download_name=file_name
            )

        return jsonify({"message": "No data available"})

    # ========== STUDENT RECORD ENDPOINT ==========
    @app.route("/student_record_info", methods=["GET", "POST"])
    @login_required(role_required=["administrator", "viewer"])
    def student_record():
        conn = create_conn()
        cur = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)

        if request.method == 'POST':
            data = request.get_json() or {}
        
            if (data != {}):
                student_id = data.get("student_id")
                
                cur.execute("SELECT * from student_info where id=%s;", (student_id,))
                result = cur.fetchone()
            
                if result is not None:
                    return jsonify(result)
                else:
                    return jsonify({"message": "The student_id doesn't exist"})

        if request.method == 'GET':
            cur.execute("SELECT * from student_info;")
            result = cur.fetchall()
        
            return jsonify(result)

        cur.close()
        conn.close()

    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True, port=5000, host="0.0.0.0")
